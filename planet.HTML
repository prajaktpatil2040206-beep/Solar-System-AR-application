<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simple AR Sphere</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, Helvetica, sans-serif; }
        #info {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 12px;
            border-radius: 30px;
            width: fit-content;
            margin: 0 auto;
            pointer-events: none;
            z-index: 10;
            font-size: 16px;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>
    <div id="info">üîç Move your phone slowly to detect a surface</div>

    <!-- Import Three.js and ARButton -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- 1. Setup scene, camera, renderer (with alpha for camera background) ---
        const scene = new THREE.Scene();
        // No background color set ‚Äì camera feed will show through

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true  // Required to see camera feed
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true;
        renderer.setClearColor(0x000000, 0); // Fully transparent
        document.body.appendChild(renderer.domElement);

        // --- 2. Lighting ---
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        // --- 3. Create a simple sphere (Earth texture) ---
        const geometry = new THREE.SphereGeometry(0.2, 64, 64);
        const textureLoader = new THREE.TextureLoader();
        const earthMaterial = new THREE.MeshStandardMaterial({
            map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg')
        });
        const sphere = new THREE.Mesh(geometry, earthMaterial);
        sphere.visible = false; // Hide until surface detected
        scene.add(sphere);

        // --- 4. Optional: a reticle to show where the sphere will be placed ---
        const reticleGeometry = new THREE.RingGeometry(0.15, 0.2, 32);
        const reticleMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
        const reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
        reticle.rotation.x = -Math.PI / 2; // Lay flat
        reticle.visible = false;
        scene.add(reticle);

        // --- 5. AR button and hit-test setup ---
        const button = ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test']
        });
        document.body.appendChild(button);

        let hitTestSource = null;
        let hitTestSourceRequested = false;

        renderer.xr.addEventListener('sessionstart', async () => {
            const session = renderer.xr.getSession();
            const viewerSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        });

        // --- 6. Animation loop (runs every frame) ---
        renderer.setAnimationLoop((timestamp, frame) => {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);

                        if (pose) {
                            // Update reticle position
                            reticle.visible = true;
                            reticle.position.copy(pose.transform.position);

                            // Place sphere on first detection
                            if (!sphere.visible) {
                                sphere.visible = true;
                                sphere.position.copy(pose.transform.position);
                                sphere.position.y += 0.2; // Lift so it sits on surface
                            }
                        }
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            // Rotate sphere if visible
            if (sphere.visible) {
                sphere.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        });

        // --- Handle window resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>