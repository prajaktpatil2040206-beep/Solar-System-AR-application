<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Cube â€“ Fixed Visibility</title>
    <style>
        body { margin:0; overflow:hidden; background:black; }
        #video-bg {
            position:fixed; top:0; left:0; width:100%; height:100%;
            object-fit:cover; z-index:0; pointer-events:none;
        }
        #canvas-container {
            position:fixed; top:0; left:0; width:100%; height:100%;
            z-index:1; pointer-events:none;
        }
        #status {
            position:absolute; bottom:30px; left:20px; right:20px;
            text-align:center; color:white; background:rgba(0,0,0,0.6);
            backdrop-filter:blur(5px); padding:12px; border-radius:40px;
            width:fit-content; margin:0 auto; z-index:2;
            font-size:16px; border:1px solid rgba(255,255,255,0.2);
        }
        #permission-btn {
            position:absolute; top:20px; right:20px; z-index:3;
            background:#1e2a3a; color:white; border:2px solid #4aa3ff;
            border-radius:40px; padding:12px 24px; font-size:16px;
            font-weight:bold; display:none; cursor:pointer;
        }
    </style>
</head>
<body>
    <video id="video-bg" autoplay playsinline></video>
    <div id="canvas-container"></div>
    <button id="permission-btn">ðŸ”˜ Enable Motion Sensors</button>
    <div id="status">ðŸŒ€ Initializing...</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.128.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Camera feed ---
        const video = document.getElementById('video-bg');
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' }, 
                    audio: false 
                });
                video.srcObject = stream;
            } catch (err) {
                document.getElementById('status').innerText = 'âŒ Camera denied';
            }
        }
        startCamera();

        // --- Three.js setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(1, 2, 3);
        scene.add(light);
        // Add a point light near the cube to guarantee illumination
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(0, 0, -2);
        scene.add(pointLight);

        // --- AR Group (holds our object) ---
        const arGroup = new THREE.Group();
        // Place it 2 meters in front of camera
        arGroup.position.set(0, 0, -2);
        scene.add(arGroup);

        // --- Create a large, vibrant cube (size 1.5 for visibility) ---
        const colors = [
            0xff3333, 0x33ff33, 0x3333ff,
            0xffff33, 0xff33ff, 0x33ffff
        ];
        const materials = colors.map(c => new THREE.MeshStandardMaterial({ 
            color: c, 
            emissive: c,        // slight self-illumination
            emissiveIntensity: 0.2,
            roughness: 0.2, 
            metalness: 0.1 
        }));
        const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const cube = new THREE.Mesh(geometry, materials);
        arGroup.add(cube);

        // Add a small wireframe sphere around it to help with depth perception
        const sphereGeo = new THREE.SphereGeometry(1.0, 16, 16);
        const sphereMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.2 
        });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        arGroup.add(sphere);

        // --- Device orientation handling (standard YXZ order) ---
        let orientationAvailable = false;
        const statusEl = document.getElementById('status');
        const permissionBtn = document.getElementById('permission-btn');
        const targetQuat = new THREE.Quaternion();

        function handleOrientation(event) {
            if (event.alpha === null || event.beta === null || event.gamma === null) return;

            const degToRad = Math.PI / 180;
            // Standard mapping: YXZ order (yaw, pitch, roll)
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(event.beta),  // pitch (X)
                THREE.MathUtils.degToRad(event.alpha), // yaw   (Y)
                THREE.MathUtils.degToRad(-event.gamma), // roll  (Z) â€“ sign adjusted
                'YXZ'
            );
            const rawQuat = new THREE.Quaternion().setFromEuler(euler);

            if (!orientationAvailable) {
                targetQuat.copy(rawQuat);
                orientationAvailable = true;
                statusEl.innerText = 'ðŸŸ¢ Sensors active â€“ cube should be visible';
                permissionBtn.style.display = 'none';
            } else {
                targetQuat.slerp(rawQuat, 0.15);
            }

            // Apply inverse to group so cube appears fixed in world
            arGroup.quaternion.copy(targetQuat).invert();
        }

        // iOS permission
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            permissionBtn.style.display = 'block';
            permissionBtn.addEventListener('click', () => {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            statusEl.innerText = 'ðŸŸ¢ Sensors active';
                        } else {
                            statusEl.innerText = 'âŒ Sensor permission denied';
                        }
                    })
                    .catch(console.error);
            });
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
            permissionBtn.style.display = 'none';
        }

        // Fallback message if no orientation after 3 sec
        setTimeout(() => {
            if (!orientationAvailable) {
                statusEl.innerText = 'âš ï¸ No sensors â€“ cube fixed at center';
            }
        }, 3000);

        // --- Animation ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>