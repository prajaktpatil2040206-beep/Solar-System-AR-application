<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Live Solar System ‚Äì camera background, orbits & rotation</title>
    <!-- Three.js core, orbit controls, and dat.GUI -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.16.0/dist/lil-gui.esm.min.js"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            pointer-events: none;
            z-index: 10;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            color: #0f0;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 13px;
            z-index: 10;
            font-family: monospace;
            backdrop-filter: blur(4px);
            border: 1px solid #00ffaa30;
        }
        .controls-note {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.6);
            background: rgba(0,0,0,0.3);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 13px;
            backdrop-filter: blur(4px);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="info">ü™ê Solar System ‚Ä¢ Live camera background ‚Ä¢ Planets orbit & rotate</div>
    <div id="status">üì° Initializing camera...</div>
    <div class="controls-note">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // --- 1. SETUP RENDERER & CAMERA ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(60, 40, 140);
        camera.lookAt(0, 0, 0);

        const scene = new THREE.Scene();
        
        // --- 2. LIVE CAMERA BACKGROUND (with fallback) ---
        const video = document.createElement('video');
        video.autoplay = true;
        video.muted = true;
        video.playsInline = true;
        
        let videoTexture = null;
        // Default background while camera loads (will be replaced)
        scene.background = new THREE.Color(0x0a0a20); 

        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }) // use rear camera if available
            .then(stream => {
                video.srcObject = stream;
                video.play();
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.colorSpace = THREE.SRGBColorSpace;
                scene.background = videoTexture;
                document.getElementById('status').innerHTML = '‚úÖ Camera active';
            })
            .catch(err => {
                console.warn('Camera access denied or not available:', err);
                document.getElementById('status').innerHTML = '‚ö†Ô∏è No camera ‚Äì using gradient';
                // Create a subtle gradient background as fallback
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                const grd = ctx.createLinearGradient(0, 0, 0, 512);
                grd.addColorStop(0, '#0a0a2a');
                grd.addColorStop(1, '#1a1a3a');
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 512, 512);
                scene.background = new THREE.CanvasTexture(canvas);
            });

        // --- 3. ORBIT CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = false;
        controls.maxDistance = 400;
        controls.minDistance = 30;
        controls.target.set(0, 0, 0);

        // --- 4. LIGHTING ---
        // Ambient light (will be toggled by "Real view" mode)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        // Point light at sun position
        const sunLight = new THREE.PointLight(0xffeedd, 2, 0, 0);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);
        
        // Additional directional light to help visibility
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        // --- 5. LOAD TEXTURES (with placeholders if missing) ---
        const loader = new THREE.TextureLoader();
        // Helper to load or return a colored texture if image missing
        function loadTexture(url, fallbackColor = '#cccccc') {
            try {
                return loader.load(url);
            } catch {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = fallbackColor;
                ctx.fillRect(0, 0, 64, 64);
                return new THREE.CanvasTexture(canvas);
            }
        }

        // Using your texture paths ‚Äì ensure they exist in 'images/' folder
        const tex = {
            sun: loadTexture('images/sun.jpg', '#ffaa33'),
            mercury: loadTexture('images/mercury.jpg', '#aaaaaa'),
            venus: loadTexture('images/venus.jpg', '#ddaa66'),
            earth: loadTexture('images/earth.jpg', '#2277ff'),
            mars: loadTexture('images/mars.jpg', '#cc6600'),
            jupiter: loadTexture('images/jupiter.jpg', '#c99a6b'),
            saturn: loadTexture('images/saturn.jpg', '#e0b060'),
            saturnRing: loadTexture('images/saturn_ring.png', '#bba070'),
            uranus: loadTexture('images/uranus.jpg', '#6fd4d4'),
            uranusRing: loadTexture('images/uranus_ring.png', '#a0c0c0'),
            neptune: loadTexture('images/neptune.jpg', '#3b5ce7')
        };

        // --- 6. CREATE SUN (emissive material) ---
        const sunGeo = new THREE.SphereGeometry(12, 64, 64);
        const sunMat = new THREE.MeshStandardMaterial({ map: tex.sun, emissive: new THREE.Color(0xffaa33), emissiveIntensity: 0.8 });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);

        // --- 7. DATA FOR PLANETS (radius, distance, speed, texture, ring) ---
        const planetsData = [
            { name: 'Mercury', radius: 2.5, distance: 22, tex: tex.mercury, orbitSpeed: 0.008, rotateSpeed: 0.004 },
            { name: 'Venus',   radius: 3.2, distance: 32, tex: tex.venus,   orbitSpeed: 0.005, rotateSpeed: 0.002 },
            { name: 'Earth',   radius: 3.4, distance: 44, tex: tex.earth,   orbitSpeed: 0.004, rotateSpeed: 0.006 },
            { name: 'Mars',    radius: 2.8, distance: 54, tex: tex.mars,    orbitSpeed: 0.0035, rotateSpeed: 0.005 },
            { name: 'Jupiter', radius: 6.0, distance: 72, tex: tex.jupiter, orbitSpeed: 0.002,  rotateSpeed: 0.009 },
            { name: 'Saturn',  radius: 5.0, distance: 92, tex: tex.saturn,  orbitSpeed: 0.0015, rotateSpeed: 0.007, ring: { inner: 7, outer: 12, tex: tex.saturnRing } },
            { name: 'Uranus',  radius: 4.0, distance: 112, tex: tex.uranus, orbitSpeed: 0.001,  rotateSpeed: 0.005, ring: { inner: 5.5, outer: 9, tex: tex.uranusRing } },
            { name: 'Neptune', radius: 4.0, distance: 132, tex: tex.neptune, orbitSpeed: 0.0008, rotateSpeed: 0.004 }
        ];

        // Arrays to hold planet objects for animation
        const planets = [];
        const orbitLines = [];

        // Function to create a circular orbit line
        function createOrbitLine(radius, color = 0x88aaff) {
            const points = [];
            const segments = 128;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(radius * Math.cos(angle), 0, radius * Math.sin(angle)));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color });
            const line = new THREE.LineLoop(geometry, material);
            scene.add(line);
            return line;
        }

        // Create each planet and its orbit
        planetsData.forEach((data) => {
            // Orbit line
            const orbitColor = options?.darkMode ? 0xffffff : 0x446688; // will be updated later
            const line = createOrbitLine(data.distance, orbitColor);
            orbitLines.push(line);

            // Planet sphere
            const geo = new THREE.SphereGeometry(data.radius, 48, 48);
            const mat = new THREE.MeshStandardMaterial({ map: data.tex });
            const planetMesh = new THREE.Mesh(geo, mat);
            
            // Create a container to handle orbit rotation
            const container = new THREE.Object3D();
            container.position.set(data.distance, 0, 0); // initial position on X axis
            planetMesh.position.set(0, 0, 0); // planet relative to container
            
            // Add ring if exists
            if (data.ring) {
                const ringGeo = new THREE.RingGeometry(data.ring.inner, data.ring.outer, 64);
                const ringMat = new THREE.MeshStandardMaterial({ map: data.ring.tex, side: THREE.DoubleSide, transparent: true });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.rotation.z = 0.2; // slight tilt
                planetMesh.add(ring); // attach ring to planet so it moves with it
            }

            container.add(planetMesh);
            scene.add(container);

            // Store planet data for animation
            planets.push({
                container,
                mesh: planetMesh,
                orbitSpeed: data.orbitSpeed,
                rotateSpeed: data.rotateSpeed,
                name: data.name
            });
        });

        // --- 8. GUI OPTIONS ---
        const gui = new GUI({ title: 'Controls', width: 260 });
        const options = {
            'Real view': true,      // ambient light low
            'Show paths': true,
            'Dark mode': false,      // path color, tooltip style
            speed: 1.0,
            pause: false
        };

        // Update orbit line colors based on dark mode
        function updateOrbitColors(isDark) {
            orbitLines.forEach(line => {
                line.material.color.setHex(isDark ? 0xffffff : 0x446688);
            });
        }

        gui.add(options, 'Real view').onChange(val => {
            ambientLight.intensity = val ? 0.2 : 0.6;
        });
        gui.add(options, 'Show paths').onChange(val => {
            orbitLines.forEach(line => line.visible = val);
        });
        gui.add(options, 'Dark mode').onChange(val => {
            updateOrbitColors(val);
            // also adjust tooltip style (tooltip created below)
            const tooltip = document.getElementById('planet-tooltip');
            if (tooltip) {
                tooltip.style.background = val ? 'rgba(20,20,30,0.9)' : 'rgba(240,240,240,0.9)';
                tooltip.style.color = val ? 'white' : 'black';
            }
        });
        gui.add(options, 'speed', 0, 3).step(0.1);
        gui.add(options, 'pause');

        // Add per-planet speed controls
        const planetsFolder = gui.addFolder('Planet Speeds');
        planets.forEach(p => {
            const folder = planetsFolder.addFolder(p.name);
            folder.add(p, 'orbitSpeed', 0, 0.02).name('Orbit speed');
            folder.add(p, 'rotateSpeed', 0, 0.02).name('Rotate speed');
            folder.open();
        });
        planetsFolder.open();

        // Initial states
        ambientLight.intensity = 0.2; // real view on
        updateOrbitColors(false);

        // --- 9. TOOLTIP FOR HOVER ---
        const tooltip = document.createElement('div');
        tooltip.id = 'planet-tooltip';
        tooltip.style.position = 'absolute';
        tooltip.style.padding = '6px 14px';
        tooltip.style.background = 'rgba(240,240,240,0.9)';
        tooltip.style.color = 'black';
        tooltip.style.borderRadius = '20px';
        tooltip.style.fontSize = '14px';
        tooltip.style.fontWeight = '500';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.zIndex = '1000';
        tooltip.style.display = 'none';
        tooltip.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
        tooltip.style.backdropFilter = 'blur(5px)';
        document.body.appendChild(tooltip);

        // Raycaster for mouse hover
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const hoveredObjects = [];

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // --- 10. ADD SOME BACKGROUND STARS (optional) ---
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 800;
        const starsPos = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount; i++) {
            const r = 300 + Math.random() * 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starsPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            starsPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            starsPos[i*3+2] = r * Math.cos(phi);
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.6 });
        const stars = new THREE.Points(starsGeo, starsMat);
        scene.add(stars);

        // --- 11. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000; // seconds

            if (!options.pause) {
                // Rotate sun
                sun.rotation.y += 0.002 * options.speed;

                // Update planets: orbit and self-rotation
                planets.forEach(planet => {
                    // Orbit: rotate container around Y axis
                    planet.container.rotation.y += planet.orbitSpeed * options.speed * delta * 30; // scale for reasonable speed
                    
                    // Self-rotation: rotate the mesh
                    planet.mesh.rotation.y += planet.rotateSpeed * options.speed * delta * 30;
                });
            }

            // --- Hover detection ---
            // Collect all planet meshes and sun for raycasting
            const meshesToTest = [sun, ...planets.map(p => p.mesh)];
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshesToTest);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                let name = '';
                if (hit === sun) {
                    name = '‚òÄÔ∏è Sun';
                } else {
                    const planetEntry = planets.find(p => p.mesh === hit);
                    if (planetEntry) name = planetEntry.name;
                }
                if (name) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = (mouse.x * 0.5 + 0.5) * window.innerWidth + 15 + 'px';
                    tooltip.style.top = (mouse.y * -0.5 + 0.5) * window.innerHeight - 40 + 'px';
                    tooltip.textContent = name;
                }
            } else {
                tooltip.style.display = 'none';
            }

            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- 12. RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 13. INIT STATUS UPDATE ---
        setTimeout(() => {
            if (!videoTexture) {
                document.getElementById('status').innerHTML = '‚ö†Ô∏è Using fallback background';
            }
        }, 3000);
    </script>
</body>
</html>